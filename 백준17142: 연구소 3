연구소 3 성공
 

 
시간 제한메모리 제한제출정답맞힌 사람정답 비율
0.25 초 (하단 참고)	512 MB	31453	9187	5239	25.604%
문제
인체에 치명적인 바이러스를 연구하던 연구소에 승원이가 침입했고, 바이러스를 유출하려고 한다. 바이러스는 활성 상태와 비활성 상태가 있다. 가장 처음에 모든 바이러스는 비활성 상태이고, 활성 상태인 바이러스는 상하좌우로 인접한 모든 빈 칸으로 동시에 복제되며, 1초가 걸린다. 승원이는 연구소의 바이러스 M개를 활성 상태로 변경하려고 한다.

연구소는 크기가 N×N인 정사각형으로 나타낼 수 있으며, 정사각형은 1×1 크기의 정사각형으로 나누어져 있다. 연구소는 빈 칸, 벽, 바이러스로 이루어져 있으며, 벽은 칸 하나를 가득 차지한다. 활성 바이러스가 비활성 바이러스가 있는 칸으로 가면 비활성 바이러스가 활성으로 변한다.

예를 들어, 아래와 같이 연구소가 생긴 경우를 살펴보자. 0은 빈 칸, 1은 벽, 2는 바이러스의 위치이다.

2 0 0 0 1 1 0
0 0 1 0 1 2 0
0 1 1 0 1 0 0
0 1 0 0 0 0 0
0 0 0 2 0 1 1
0 1 0 0 0 0 0
2 1 0 0 0 0 2
M = 3이고, 바이러스를 아래와 같이 활성 상태로 변경한 경우 6초면 모든 칸에 바이러스를 퍼뜨릴 수 있다. 벽은 -, 비활성 바이러스는 *, 활성 바이러스는 0, 빈 칸은 바이러스가 퍼지는 시간으로 표시했다.

* 6 5 4 - - 2
5 6 - 3 - 0 1
4 - - 2 - 1 2
3 - 2 1 2 2 3
2 2 1 0 1 - -
1 - 2 1 2 3 4
0 - 3 2 3 4 *
시간이 최소가 되는 방법은 아래와 같고, 4초만에 모든 칸에 바이러스를 퍼뜨릴 수 있다.

0 1 2 3 - - 2
1 2 - 3 - 0 1
2 - - 2 - 1 2
3 - 2 1 2 2 3
3 2 1 0 1 - -
4 - 2 1 2 3 4
* - 3 2 3 4 *
연구소의 상태가 주어졌을 때, 모든 빈 칸에 바이러스를 퍼뜨리는 최소 시간을 구해보자.

입력
첫째 줄에 연구소의 크기 N(4 ≤ N ≤ 50), 놓을 수 있는 바이러스의 개수 M(1 ≤ M ≤ 10)이 주어진다.

둘째 줄부터 N개의 줄에 연구소의 상태가 주어진다. 0은 빈 칸, 1은 벽, 2는 바이러스를 놓을 수 있는 위치이다. 2의 개수는 M보다 크거나 같고, 10보다 작거나 같은 자연수이다.

출력
연구소의 모든 빈 칸에 바이러스가 있게 되는 최소 시간을 출력한다. 바이러스를 어떻게 놓아도 모든 빈 칸에 바이러스를 퍼뜨릴 수 없는 경우에는 -1을 출력한다.

예제 입력 1 복사
7 3
2 0 0 0 1 1 0
0 0 1 0 1 2 0
0 1 1 0 1 0 0
0 1 0 0 0 0 0
0 0 0 2 0 1 1
0 1 0 0 0 0 0
2 1 0 0 0 0 2
예제 출력 1 복사
4
예제 입력 2 복사
7 3
2 0 2 0 1 1 0
0 0 1 0 1 2 0
0 1 1 2 1 0 0
2 1 0 0 0 0 2
0 0 0 2 0 1 1
0 1 0 0 0 0 0
2 1 0 0 2 0 2
예제 출력 2 복사
4
예제 입력 3 복사
7 4
2 0 2 0 1 1 0
0 0 1 0 1 2 0
0 1 1 2 1 0 0
2 1 0 0 0 0 2
0 0 0 2 0 1 1
0 1 0 0 0 0 0
2 1 0 0 2 0 2
예제 출력 3 복사
4
예제 입력 4 복사
7 5
2 0 2 0 1 1 0
0 0 1 0 1 2 0
0 1 1 2 1 0 0
2 1 0 0 0 0 2
0 0 0 2 0 1 1
0 1 0 0 0 0 0
2 1 0 0 2 0 2
예제 출력 4 복사
3
예제 입력 5 복사
7 3
2 0 2 0 1 1 0
0 0 1 0 1 0 0
0 1 1 1 1 0 0
2 1 0 0 0 0 2
1 0 0 0 0 1 1
0 1 0 0 0 0 0
2 1 0 0 2 0 2
예제 출력 5 복사
7
예제 입력 6 복사
7 2
2 0 2 0 1 1 0
0 0 1 0 1 0 0
0 1 1 1 1 0 0
2 1 0 0 0 0 2
1 0 0 0 0 1 1
0 1 0 0 0 0 0
2 1 0 0 2 0 2
예제 출력 6 복사
-1
예제 입력 7 복사
5 1
2 2 2 1 1
2 1 1 1 1
2 1 1 1 1
2 1 1 1 1
2 2 2 1 1
예제 출력 7 복사
0
 

#include<iostream>
#include<vector>
#include<queue>
#include<algorithm>
#include<cstring>
using namespace std;
int N, M;
int Map[51][51];

vector<pair<int, int>> pos;
vector<bool> Pvisited;

int dy[4] = { -1,1,0,0 };
int dx[4] = { 0,0,-1,1 };
int answer = 987654321;

void bfs() {
	int visited[51][51];
	memset(visited, -1, sizeof(visited));
	queue<pair<int, int>>q;
	for (int i = 0; i<Pvisited.size(); i++) {
		if (Pvisited[i]) {
			visited[pos[i].first][pos[i].second] = 0;
			q.push({ pos[i].first, pos[i].second });
		}
			
	}

	while (!q.empty()) {
		int y = q.front().first;
		int x = q.front().second;
		
		q.pop();
		for (int i = 0; i < 4; i++) {
			int ny = y + dy[i];
			int nx = x + dx[i];
			if (ny<0 || nx<0 || ny>N - 1 || nx>N - 1)continue;
			
			if (Map[ny][nx] != 1 && visited[ny][nx] == -1) {
				visited[ny][nx] = visited[y][x]+1;
				q.push({ ny,nx} );
			}	
		}
	}
	bool flag = true;
	int time = 0;
	for (int i = 0; i < N; i++) {
		for (int j = 0; j < N; j++) {
			if (Map[i][j] == 0) {//map이 0인경우만 따져야함
				if (visited[i][j] == -1) {
					//방문하지못한경우
					flag = false;
					break;
				}
				else//방문이 됬다면
					time = max(time, visited[i][j]);
			}
			
		}
	}
	if(flag)
	answer = min(time, answer);
}

void dfs(int idx, int cnt) {//search
	if (cnt == M) {
		bfs();
		return;
	}
	for (int i = idx; i < pos.size(); i++) {
		if (Pvisited[i] == false) {
			Pvisited[i] = true;
			dfs(i+1, cnt + 1);
			Pvisited[i] = false;
		}
	}
}

int main() {
	cin >> N >> M;
	for (int i = 0; i < N; i++) {
		for (int j = 0; j < N; j++) {
			cin >> Map[i][j];
			if (Map[i][j] == 2) {
				pos.push_back({ i,j });
				Pvisited.push_back(false);
			}
		}
	}
	dfs(0,0);
	if(answer!=987654321)
	cout << answer;
	else
		cout<<-1;
	return 0;
}
이 문제 솔직히 어려웠다.
구현이 어려운건 아니었지만 고려해줄 쉽게 생각할 수 없는 부분이 있다. 우선 Map[i][j]가 0인 지점만 고려해줘야한다.
Map[i][j]가 1인 비활성부분을 고려해서 맵을 전체 한바퀴를 순회하면서 max값을 찾게되면 Map이 222222이렇게 2가 붙어있다면 맨앞의 0부터 활성이 시작되면 Map에는0123456이런값이 들어가게 된다. 또한 모든 경우의수 따지는 것도 은근 까다로웠다.
하지만 난 더 잘할꺼다! 화이팅!
