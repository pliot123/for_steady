잠수함식별 성공
 

 
시간 제한메모리 제한제출정답맞힌 사람정답 비율
1 초	128 MB	5511	2147	1558	39.244%
문제
일반적으로 잠수함 엔진이 작동할 때에 나오는 소리는 잠수함의 종류에 따라서 다르다고 한다.

우리는 물속에서 들리는 소리의 패턴을 듣고서 그 소리가 특정한 잠수함에서 나오는 소리인지 아닌지를 알아내려고 한다. 이 문제에서는 잠수함의 소리가 두 종류의 단위 소리의 연속으로 이루어져 있고, 그 단위 소리를 각각 0과 1로 표시한다.

또, 한 특정한 소리의 반복은 ~로 표시한다. 예를 들어 x~는 x가 한번 이상 반복되는 모든 소리의 집합을 말하고, (xyz)~는 괄호 안에 있는 xyz로 표현된 소리가 한번 이상 반복되는 모든 소리의 집합을 말한다. 다음의 예를 보라.

1~ = {1, 11, 111, 1111, ..., 1...1, ...}
(01)~ = {01, 0101, 010101, 01010101. ...}
(1001)~ = {1001, 10011001, ..., 100110011001...1001, ...}
10~11 = {1011, 10011, 100011, ..., 1000...011, ...}
(10~1)~ = {101, 1001, 10001, 100001, ...1011001, ...100110110001101, ...}
​그리고 (x|y)는 x또는 y중에서 아무거나 하나만을 선택해서 만든 소리의 집합, 즉 집합{x, y}를 의미한다. 예를 들면(1001|0101)은 집합으로 {1001, 0101}을 의미한다. 따라서 (0|1)~은 0과 1로 이루어진 모든 스트링의 집합, 즉 모든 소리의 집합을 말한다. 또 한 예를 보면 (100|11)~은 100과 11을 마음대로 섞어서 만들 수 있는 모든 소리의 집합을 의미한다. 즉 (100|11)~에 해당하는 스트링을 집합으로 나타내면 {100, 11, 10011, 100100100, 1110011, ...}이 된다. 우리가 식별하고자 하는 잠수함의 엔진소리의 패턴은 다음과 같다.

(100~1~|01)~

여기에 속하는 소리의 예를 들어보면, 1001, 01, 100001, 010101, 1000001110101, 1001110101, 0101010101, 10010110000001111101, 01010101011000111, 10000111001111, ...이다.

다시 말해서 이것은 100~1~과 01을 임의로 섞어서 만들 수 있는 모든 스트링의 집합을 나타낸다.

입력으로 0과 1로 구성된 스트링이 주어질 때, 이 스트링이 앞에서 기술된 잠수함의 엔진소리인지 아닌지를 판별하는 프로그램을 작성하라.

입력
0과 1로 구성된 스트링이 1개 들어있다. 이때 각 스트링의 길이는 150개 이하로 제한된다.

출력
입력에 들어있는 스트링을 읽고, 이것이 잠수함의 엔진소리를 나타내는 스트링인지 아니면 그냥 물속의 잡음인지를 판정한 후, 잠수함의 엔진 소리에 해당하는 스트링이면 "SUBMARINE"을 출력하고, 그렇지 않으면 "NOISE"를 출력한다.

예제 입력 1 복사
10010111
예제 출력 1 복사
NOISE
예제 입력 2 복사
100000000001101
예제 출력 2 복사
SUBMARINE
출처
Olympiad > 한국정보올림피아드 > KOI 1996 > 중등부 2번

Olympiad > 한국정보올림피아드 > KOI 1996 > 고등부 1번

문제의 오타를 찾은 사람: chan4928, goooora
잘못된 데이터를 찾은 사람: doju
데이터를 추가한 사람: kyo20111
알고리즘 분류
문자열
정규 표현식
#include<iostream>
#include<cstring>
#include<string>
using namespace std;
//(100~1~|01)~
//10011001100110010110011111111111111111111101
int main() {
    string str;
    cin >> str;
    bool flag = false;
    int i = 0;
    int s = str.size();
    while (i < s) {
        if (str[i] == '0') {
            if (str[i + 1] == '1') {
                i += 2;
            }else if (str[i + 1] == '0') {
                break;
            }
        }
        else {
            if (str[i + 1] == '1'|| str[i + 2] == '1')break;
            else {
                i += 3;
            }
            if (i >= s) {
                i = 0;
                break;
            }

            if (str[i] == '0')
                while (str[i] == '0') i++;
            if (i >= s) {
                i = 0;
                break;
            }
            if (str[i] == '1') {
                int cnt = 0;
                while (str[i] == '1') {
                    i++;
                    cnt++;
                }
                if (str[i] == '0' && str[i + 1] == '1')i += 2;
                else if (cnt > 1 && str[i] == '0')i--;
            }
        }
    }
    if (i >= s)cout << "SUBMARINE";
    else cout << "NOISE";

    return 0;
}
정규표현식이란 걸 사용하면 되는데, 쓸줄몰라서 그냥 주먹구구식으로 풀었다. (100~1~|01)~ 이 패턴에 맞게 작동하도록하면되는데, 아마 테케가 더 많았다면 틀렸을것이다!

 

 

#include <iostream>
#include <string>
#include <regex>
using namespace std;

int main() {
    string str;
    cin>>str;
    string ptn = "(100+1+|01)+";
    if(regex_match(str,regex(ptn))) cout <<"SUBMARINE";
    else cout<<"NOISE";
    return 0;
}
정규 표현식을 이용한풀이인데 regex를 사용한다. 쓸줄 모르지만 눈에한번 익혀놓고 자주 또 등장하면 그때는 공부할 생각이다. 화이팅~!
