알고스팟 성공
 

 
시간 제한메모리 제한제출정답맞힌 사람정답 비율
1 초 (추가 시간 없음)	128 MB	28605	12039	8097	41.508%
문제
알고스팟 운영진이 모두 미로에 갇혔다. 미로는 N*M 크기이며, 총 1*1크기의 방으로 이루어져 있다. 미로는 빈 방 또는 벽으로 이루어져 있고, 빈 방은 자유롭게 다닐 수 있지만, 벽은 부수지 않으면 이동할 수 없다.

알고스팟 운영진은 여러명이지만, 항상 모두 같은 방에 있어야 한다. 즉, 여러 명이 다른 방에 있을 수는 없다. 어떤 방에서 이동할 수 있는 방은 상하좌우로 인접한 빈 방이다. 즉, 현재 운영진이 (x, y)에 있을 때, 이동할 수 있는 방은 (x+1, y), (x, y+1), (x-1, y), (x, y-1) 이다. 단, 미로의 밖으로 이동 할 수는 없다.

벽은 평소에는 이동할 수 없지만, 알고스팟의 무기 AOJ를 이용해 벽을 부수어 버릴 수 있다. 벽을 부수면, 빈 방과 동일한 방으로 변한다.

만약 이 문제가 알고스팟에 있다면, 운영진들은 궁극의 무기 sudo를 이용해 벽을 한 번에 다 없애버릴 수 있지만, 안타깝게도 이 문제는 Baekjoon Online Judge에 수록되어 있기 때문에, sudo를 사용할 수 없다.

현재 (1, 1)에 있는 알고스팟 운영진이 (N, M)으로 이동하려면 벽을 최소 몇 개 부수어야 하는지 구하는 프로그램을 작성하시오.

입력
첫째 줄에 미로의 크기를 나타내는 가로 크기 M, 세로 크기 N (1 ≤ N, M ≤ 100)이 주어진다. 다음 N개의 줄에는 미로의 상태를 나타내는 숫자 0과 1이 주어진다. 0은 빈 방을 의미하고, 1은 벽을 의미한다.

(1, 1)과 (N, M)은 항상 뚫려있다.

출력
첫째 줄에 알고스팟 운영진이 (N, M)으로 이동하기 위해 벽을 최소 몇 개 부수어야 하는지 출력한다.

예제 입력 1 복사
3 3
011
111
110
예제 출력 1 복사
3
예제 입력 2 복사
4 2
0001
1000
예제 출력 2 복사
0
예제 입력 3 복사
6 6
001111
010000
001111
110001
011010
100010
예제 출력 3 복사
2
 

 

사고

미로 크기 N*M
미로는 빈방 또는 벽
빈방은 자유롭게 이동
벽은 부셔야함
알고스팟 운영진은 
여러명이지만
항상 모두 같은방
여러명이 다른방에 
있을 수 없다
어떤 방에서 
이동할 수 있는 방은
상하좌우로
인접한 방
벽은 평소에는 이동x
알고스팟 무기
AOJ로 벽을 부순다
벽을 부수면 빈방과
동일한
방으로변함

1,1에서 N,M으로이동
하려면 벽을 최소
몇개 뿌셔야하나

bfs문제다
하나씩 깨부시면 되나?
6 6
001111  110000   q에는 0,0 pop()
010000  100000  그다음 0,2
001111  110000
110001  000000
011010  000000
100010  000000

000111  112000
010000  102222
001111  112333
110001  022220
011010  000233
100010  000003

일단 Map을보고 이어진 칸에 다 표시를 해준다. 그러면서 뚫을 수 있는 칸이 있으면 체크해서 queue에 넣어준다. 

 

#include<iostream>
#include<string>
#include<queue>
using namespace std;
int Y, X;
int Map[101][101];
int visited[101][101];
int dy[4] = { -1,1,0,0 };
int dx[4] = { 0,0,-1,1 };

void bfs() {

	queue<pair<int, int>> q;
	q.push({ 0, 0 });
	visited[0][0] = 1;


	while (!q.empty()) {//부서진 벽의 인덱스를 담을 queue
		int a = q.front().first;
		int b = q.front().second;
		Map[a][b] = 0;
		q.pop();

		queue<pair<int, int>> q2;
		q2.push({ a, b });
		while (!q2.empty()) {
			int y = q2.front().first;
			int x = q2.front().second;
			q2.pop();

			for (int i = 0; i < 4; i++) {
				int ny = y + dy[i];
				int nx = x + dx[i];

				if (ny < 0 || nx < 0 || ny >= X || nx >= Y)continue;
				if (Map[ny][nx] == 0 && visited[ny][nx] == 0) {
					visited[ny][nx] = visited[a][b];
					q2.push({ ny, nx });
				}

				if (Map[ny][nx] == 1 && visited[ny][nx] == 0) {
					visited[ny][nx] = visited[a][b] + 1;
					q.push({ ny, nx });
				}

			}

		}


	}
}

int main(void) {
	cin >> Y >> X;// 4 2
	for (int i = 0; i < X; i++) {//2
		string s;
		cin >> s;
		for (int j = 0; j < Y; j++) {//4
			Map[i][j] = s[j] - '0';
		}
	}

	bfs();

	/*for (int i = 0; i < 10; i++) {
		for (int j = 0; j < 10; j++) {
			cout << visited[i][j] << ' ';
		}cout << endl;
	}
	*/
	cout << max(0,visited[X - 1][Y - 1]-1);



	return 0;
}
