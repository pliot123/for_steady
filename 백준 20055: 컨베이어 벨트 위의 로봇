문제

길이가 N인 컨베이어 벨트가 있고, 길이가 2N인 벨트가 이 컨베이어 벨트를 위아래로 감싸며 돌고 있다. 벨트는 길이 1 간격으로 2N개의 칸으로 나뉘어져 있으며, 각 칸에는 아래 그림과 같이 1부터 2N까지의 번호가 매겨져 있다.


벨트가 한 칸 회전하면 1번부터 2N-1번까지의 칸은 다음 번호의 칸이 있는 위치로 이동하고, 2N번 칸은 1번 칸의 위치로 이동한다. i번 칸의 내구도는 Ai이다. 위의 그림에서 1번 칸이 있는 위치를 "올리는 위치", N번 칸이 있는 위치를 "내리는 위치"라고 한다.

컨베이어 벨트에 박스 모양 로봇을 하나씩 올리려고 한다. 로봇은 올리는 위치에만 올릴 수 있다. 언제든지 로봇이 내리는 위치에 도달하면 그 즉시 내린다. 로봇은 컨베이어 벨트 위에서 스스로 이동할 수 있다. 로봇을 올리는 위치에 올리거나 로봇이 어떤 칸으로 이동하면 그 칸의 내구도는 즉시 1만큼 감소한다.

컨베이어 벨트를 이용해 로봇들을 건너편으로 옮기려고 한다. 로봇을 옮기는 과정에서는 아래와 같은 일이 순서대로 일어난다.

벨트가 각 칸 위에 있는 로봇과 함께 한 칸 회전한다.
가장 먼저 벨트에 올라간 로봇부터, 벨트가 회전하는 방향으로 한 칸 이동할 수 있다면 이동한다. 만약 이동할 수 없다면 가만히 있는다.
로봇이 이동하기 위해서는 이동하려는 칸에 로봇이 없으며, 그 칸의 내구도가 1 이상 남아 있어야 한다.
올리는 위치에 있는 칸의 내구도가 0이 아니면 올리는 위치에 로봇을 올린다.
내구도가 0인 칸의 개수가 K개 이상이라면 과정을 종료한다. 그렇지 않다면 1번으로 돌아간다.
종료되었을 때 몇 번째 단계가 진행 중이었는지 구해보자. 가장 처음 수행되는 단계는 1번째 단계이다.

입력
첫째 줄에 N, K가 주어진다. 둘째 줄에는 A1, A2, ..., A2N이 주어진다.

출력
몇 번째 단계가 진행 중일때 종료되었는지 출력한다.

제한
2 ≤ N ≤ 100
1 ≤ K ≤ 2N
1 ≤ Ai ≤ 1,000
예제 입력 1 복사
3 2
1 2 1 2 1 2
예제 출력 1 복사
2
예제 입력 2 복사
3 6
10 10 10 10 10 10
예제 출력 2 복사
31
예제 입력 3 복사
4 5
10 1 10 6 3 4 8 2
예제 출력 3 복사
24
예제 입력 4 복사
5 8
100 99 60 80 30 20 10 89 99 100


예제 출력 4 복사
472
출처
문제를 만든 사람: baekjoon
baekjoon 정보

www.acmicpc.net


사고 과정 


길이가 N인 컨베이어벨트가 있고 2N인 벨트가 위아래로 감싸고 돌아간다.
벨트는 길이1간격으로 2N개의 칸으로 나눠져있고 순서대로 움직인다.

맨 왼쪽에서는 올리고 맨 오른쪽으로 가면 내린다.
박스형 로봇을 올리면 내구도가 1 깍이고 로봇이 이동해도 1깍인다.(즉시깍인다)
로봇은 스스로 이동이 가능하다.

컨베이터 벨트를 이용해서 로봇을 올렸다가 내리려고 한다.

1. 벨트가 각 칸 위에 있는 로봇과 함께 한 칸 회전한다.
2. 가장 먼저 벨트에 올라간 로봇부터 오른쪽으로 한칸 씩 건너가는데, 로봇이 이동하기 위해서 이동하려는 칸에 로봇이 없으며 내구도가 1이상이어야 이동이 가능하다.
3. 올리는 위치에 있는 칸의 내구도가 9이 아니면 올리는 위치에 로봇을 올린다.
4. 내구도가 0인 칸의 개수가 K개 이상이라면 과정을 종료 아니면 1번단계로 돌아간다.
종료되었을 때 몇 번째 단계가 진행중이었는지 구해보자.

로봇을 어떤 배열에 만들고 넣어야할 지 모르겠다
queue,vector,array 세개 다 어찌어찌하면 가능할 꺼 같은데, 뭐 하나도 깔끔한 방식이 생각나지 않는다.

해답을 찾았다.
덱(deque)을 사용하면 된다.
이 문제를 덱을 사용하면 구냥 간편해결이 된다.

코드

#include <iostream>
#include <vector>
#include <deque>
using namespace std;

int N,K;
deque <bool> visited;
deque <int> dq; 
int step;

void simul() {
while (1) {
step++;
dq.push_front(dq.back());//맨 앞에 맨 마지막꺼 넣어주고
dq.pop_back();//맨 뒤에꺼 지우고
//벨트회전 
visited.push_front(visited.back());
visited.pop_back();//로봇 회전

//1단계 끝
if (visited[N - 1] == true)visited[N - 1] = false;
//끝 로봇은 하차

for (int i = N - 2; i >= 0; i--) {
if (visited[i] == true && visited[i + 1] == false && dq[i + 1] >= 1) {
visited[i] = false, dq[i + 1]--;
if (i == N - 2)continue;
visited[i + 1] = true;
}
}
//2단계 끝
if (dq[0] >= 1 && visited[0]==false) {
dq[0]--, visited[0] = true;
}
//3단계 끝
int k = 0;
for (int i = 0; i < dq.size(); i++) {
if (dq[i] == 0)k++;
}
if (k >= K) {
cout << step;
break;
}
//4단계 끝
}
}

int main() {
cin >> N >> K;

for (int i = 0; i < 2*N; i++) {
int input;
cin >> input;
dq.push_back(input);
visited.push_back(false);
}
simul();

return 0;
}

왜 갑자기 코드가 또 왼쪽에 붙은지 잘 모르겠다.

근데 덱은 아주 강력한거 같다. 시간복잡도O(1)인데다가 큐와 스택을 동시에 활용하는 기분이랄까...?

좋은 공부가 되었다.
