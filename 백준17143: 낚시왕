문제
낚시왕이 상어 낚시를 하는 곳은 크기가 R×C인 격자판으로 나타낼 수 있다. 격자판의 각 칸은 (r, c)로 나타낼 수 있다. r은 행, c는 열이고, (R, C)는 아래 그림에서 가장 오른쪽 아래에 있는 칸이다. 칸에는 상어가 최대 한 마리 들어있을 수 있다. 상어는 크기와 속도를 가지고 있다.


낚시왕은 처음에 1번 열의 한 칸 왼쪽에 있다. 다음은 1초 동안 일어나는 일이며, 아래 적힌 순서대로 일어난다. 낚시왕은 가장 오른쪽 열의 오른쪽 칸에 이동하면 이동을 멈춘다.

낚시왕이 오른쪽으로 한 칸 이동한다.
낚시왕이 있는 열에 있는 상어 중에서 땅과 제일 가까운 상어를 잡는다. 상어를 잡으면 격자판에서 잡은 상어가 사라진다.
상어가 이동한다.
상어는 입력으로 주어진 속도로 이동하고, 속도의 단위는 칸/초이다. 상어가 이동하려고 하는 칸이 격자판의 경계를 넘는 경우에는 방향을 반대로 바꿔서 속력을 유지한채로 이동한다.

왼쪽 그림의 상태에서 1초가 지나면 오른쪽 상태가 된다. 상어가 보고 있는 방향이 속도의 방향, 왼쪽 아래에 적힌 정수는 속력이다. 왼쪽 위에 상어를 구분하기 위해 문자를 적었다.


상어가 이동을 마친 후에 한 칸에 상어가 두 마리 이상 있을 수 있다. 이때는 크기가 가장 큰 상어가 나머지 상어를 모두 잡아먹는다.

낚시왕이 상어 낚시를 하는 격자판의 상태가 주어졌을 때, 낚시왕이 잡은 상어 크기의 합을 구해보자.

입력
첫째 줄에 격자판의 크기 R, C와 상어의 수 M이 주어진다. (2 ≤ R, C ≤ 100, 0 ≤ M ≤ R×C)

둘째 줄부터 M개의 줄에 상어의 정보가 주어진다. 상어의 정보는 다섯 정수 r, c, s, d, z (1 ≤ r ≤ R, 1 ≤ c ≤ C, 0 ≤ s ≤ 1000, 1 ≤ d ≤ 4, 1 ≤ z ≤ 10000) 로 이루어져 있다. (r, c)는 상어의 위치, s는 속력, d는 이동 방향, z는 크기이다. d가 1인 경우는 위, 2인 경우는 아래, 3인 경우는 오른쪽, 4인 경우는 왼쪽을 의미한다.

두 상어가 같은 크기를 갖는 경우는 없고, 하나의 칸에 둘 이상의 상어가 있는 경우는 없다.

출력
낚시왕이 잡은 상어 크기의 합을 출력한다.

예제 입력 1 복사
4 6 8
4 1 3 3 8
1 3 5 2 9
2 4 8 4 1
4 5 0 1 4
3 3 1 2 7
1 5 8 4 3
3 6 2 1 2
2 2 2 3 5
예제 출력 1 복사
22
각 칸의 왼쪽 아래에 적힌 수는 속력, 오른쪽 아래는 크기, 왼쪽 위는 상어를 구분하기 위한 문자이다. 오른쪽 위에 ❤️는 낚시왕이 잡은 물고기 표시이다.


초기 상태


1초


2초 (E번 상어는 B번에게 먹혔다)


3초


4초


5초


6초

예제 입력 2 복사
100 100 0
예제 출력 2 복사
0
예제 입력 3 복사
4 5 4
4 1 3 3 8
1 3 5 2 9
2 4 8 4 1
4 5 0 1 4
예제 출력 3 복사
22
예제 입력 4 복사
2 2 4
1 1 1 1 1
2 2 2 2 2
1 2 1 2 3
2 1 2 1 4
예제 출력 4 복사
4






첫째 줄에 격자판의 크기 R, C와 상어의 수 M이 주어진다. (2 ≤ R, C ≤ 100, 0 ≤ M ≤ R×C)

상어의 이동과 낚시왕의 이동을 따로 구현해서 1초가 지나가는 사이에 같이 돌려주면 될꺼같다. 
낚시왕이 먼저 움직이고 그 다음 상어가 이동한다.

구현에 앞서 필요한 것들을 생각해보면,
상어가 움직일 수족관,
상어를 정의할 구조체,
그리고 이동이 끝나면 한칸에 여러마리 상어가 있을 경우를 대비해서 우선순위큐,또는 벡터로 구현을 할까 생각중이다.아니면
상어가 동시에 움직이지만 한마리씩 이동했다고 생각하면 더 큰놈이 들어오면 그 자리에서 죽이는 건 어떨까?
먹혀도 먹은 상어의 크기는 변함이 없으니, 3차원으로 구현하지 않아도 될 것 같다.
만약 먹히고 난 뒤 크기가 변한다면 
만약 3, 2, 4 이렇게 있는 물고기가 있을때는
크기 4의 물고기가 2,3을 잡아먹는데,
순서대로 처리해준다면 2번이 제일먼저들어오고 2번다음 3번이 들어와서 2를 먹고 5가 되서 4번이 들어오면 4번을 먹고 9가 되는 이상한 일이 벌어 질 수도 있다. 
(그럼 그냥 다 더해주면 되서 순서를 안따지는 것이 아닌가?)
무하튼,, 3차원배열은 안써도 될 것 같다. 

구현중에 깨달았는데, 상어를 움직여줄때 만약 움직인 상어가 안움직인 상어 자리에 가면 안움직인 상어도 움직여야하기때문에, 잡아먹을 수 없다. 그렇기때문에 3차원 배열로 구성해주는 것이 맞다.
이제 움직이는 것을 구현해야하는데
움직이는 것을 for문으로 구성해버리면 
만약 10000번까지 움직이면 시간초과날 확률이 높아진다 그럼으로 한방의 식으로 짜야함

#include <iostream>
#include<vector>
#include<algorithm>
using namespace std;
int R, C, M;

struct shark {
int r, c, s, d, z;//위치,s속력,d이동방향,z크기
};
int dy[5] = { 0,-1,1,0,0 };
int dx[5] = { 0,0,0,1,-1 };
int answer = 0;
bool cmp(shark a, shark b) {
return a.z > b.z;
}
vector<shark> Map[101][101];


void move_shark() {
//움직일때는 항상 한칸에 하나의 상어밖에없다.

vector<shark> newMap[101][101];
for (int i = 1; i <= R; i++) {
for (int j = 1; j <= C; j++) {
if (!Map[i][j].empty()) {
shark sh = Map[i][j][0];
Map[i][j].pop_back();
int nr=sh.r, nc=sh.c;
if (sh.d == 1 || sh.d == 2) {//위 아래로 이동
for (int a = 0; a < sh.s; a++) {
if (sh.r == 1 || sh.r == R) {
if(sh.r == 1 && sh.d == 1)sh.d=2;
if(sh.r == R && sh.d == 2)sh.d=1;
}
sh.r += dy[sh.d];
sh.c += dx[sh.d];
}
nr = sh.r; 
nc = sh.c;
}
else if (sh.d == 3 || sh.d == 4) {//가로세로로 이동
for (int a = 0; a < sh.s; a++) {
if (sh.c == 1 || sh.c == C) {
if (sh.c == 1 && sh.d == 4)sh.d=3;
if (sh.c == C && sh.d == 3)sh.d=4;
}
sh.r += dy[sh.d];
sh.c += dx[sh.d];
}
nr = sh.r;
nc = sh.c;
}
if (!newMap[nr][nc].empty()) {
if (newMap[nr][nc][0].z < sh.z) {
newMap[nr][nc].pop_back();
newMap[nr][nc].push_back(sh);
}
} // 상어가 없으면 바로 push 
else newMap[nr][nc].push_back(sh);
}
}
}

for (int i = 1; i <= R; i++) {
for (int j = 1; j <= C; j++) {
if (!newMap[i][j].empty()) {
Map[i][j].push_back(newMap[i][j][0]);
newMap[i][j].pop_back();
}
}
}
}
void move_king(int k) {
for (int i = 1; i <= R; i++) {
if (!Map[i][k].empty()) {
answer += Map[i][k][0].z;
Map[i][k].pop_back();
break;
}
}
}
void solve() {
int idx = 1;
int k = C;
while (k--) {
move_king(idx);
move_shark();
idx++;
}
}

int main() {

cin >> R >> C >> M;

for (int i = 0; i < M; i++) {
int r, c, s, d, z;
cin >> r >>c >>s >>d >>z;
if (d == 1 || d == 2) s %= ((R - 1) * 2); 
if (d == 3 || d == 4) s %= ((C - 1) * 2);
Map[r][c].push_back({ r,c,s,d,z });
}
solve();
cout << answer;
return 0;
}

그렇게 어려운 구현은 아닌데, 마냥 쉬운 구현도 아니다. 그리고 고려해야할 부분이 많아서 실수하면 어디서 틀렸는지 찾는데 오지게 걸린다. 나는R과 C가 헷갈려서 낚시왕이동을 R축으로안하고 C축으로하고 예제는 맞는데 왜틀리지? 라면서 한참 해맸다. 쬬욨같당.
